
lootTables = [ # add a loot table to add items to
    "minecraft:empty",
    "minecraft:chests/bastion_treasure",
]

insertTables = [ # add the loot tables that will be added to the loot table with the same index
    [ "minecraft:chests/buried_treasure", "minecraft:blocks/activator_rail" ],
    [ "minecraft:chests/buried_treasure", "minecraft:chests/end_city_treasure" ],
]

yourNamespace = "test" # the namespace the insersion functions can be found under for compatibilty reasons

#> Add gold scoreboard

function gold:_technical/load:
    scoreboard objectives add gold dummy
    unless score .rseed gold = .rseed gold store result score .rseed gold run seed
    scoreboard players set .rmod gold 1234567
    scoreboard players set .2 gold 2

    scoreboard objectives add config.gold dummy
    unless score .shuffle config.gold = .shuffle config.gold run scoreboard players set .shuffle config.gold 2 # 1 shuffles all but original || 2 summons marker and shuffles all

function_tag minecraft:load: # change to `append function_tag load:load:` if using lantern load
    { "values": [ "gold:_technical/load" ] }

#> Logic

for idx, lootTable in enumerate(lootTables):
    withSlash = lootTable.replace(":", "/")
    withDot = withSlash.replace("/", ".")

    advancement f'gold:{withSlash}':
        {
            "criteria": {
                "requirement": {
                "trigger": "minecraft:player_generates_container_loot",
                "conditions": {
                    "loot_table": f'{lootTable}'
                }
                }
            },
            "rewards": {
                "function": f'gold:{withSlash}'
            }
        }

    function f'gold:{withSlash}':
        advancement revoke @s only f'gold:{withSlash}'

        scoreboard players set .dist gold 30
        anchored eyes positioned ^ ^ ^0.2 run function f'gold:{withSlash}_raycast'

    function f'gold:{withSlash}_raycast':
        scoreboard players remove .dist gold 1

        unless score .shuffle config.gold matches 2 if block ~ ~ ~ #gold:container run function f'gold:{withSlash}_insert'
        if score .shuffle config.gold matches 2 if block ~ ~ ~ #gold:container run summon marker ~ ~ ~ {Tags:[f'{withDot}', "gold.shuffle"]}
        if score .shuffle config.gold matches 2 if block ~ ~ ~ #gold:container run scoreboard players set .dist gold 0

        if score .dist gold matches 1.. positioned ^ ^ ^0.2 run function f'gold:{withSlash}_raycast'

    function f'gold:{withSlash}_insert':
        function f'#gold:{withSlash}' # let every pack populate the chest
        if score .shuffle config.gold matches 1..2 run function gold:_technical/shuffle
        scoreboard players set .dist gold 0

    function f'{yourNamespace}:gold/{withSlash}_insert':
        for insert in insertTables[idx]:
            loot insert ~ ~ ~ loot f'{insert}'

    function_tag f'gold:{withSlash}':
        { "values": [ f'{yourNamespace}:gold/{withSlash}_insert' ]}

#> Delay Shuffle

function gold:_technical/open_chest:
    advancement revoke @s only gold:_technical/open_chest
    execute as @e[type=marker, tag=gold.shuffle, limit=1] at @s function gold:_technical/open_chest_marker

function gold:_technical/open_chest_marker:
    data remove block ~ ~ ~ Items
    for lootTable in lootTables:
        withSlash = lootTable.replace(":", "/")
        withDot = withSlash.replace("/", ".")
        if entity @s[tag=f'{withDot}'] run loot insert ~ ~ ~ loot f'{lootTable}'
        if entity @s[tag=f'{withDot}'] run function f'gold:{withSlash}_insert'
    kill





#> Shuffle

function gold:_technical/shuffle:
    data modify storage gold:container Items set from block ~ ~ ~ Items
    store result score .stacks gold run data remove block ~ ~ ~ Items[]
    scoreboard players set .occupied gold 0
    if block ~ ~ ~ #gold:nine_slots run function gold:_technical/add_item_9
    unless block ~ ~ ~ #gold:nine_slots run function gold:_technical/add_item_27

for amount in [ 9, 27 ]:
    function f'gold:_technical/add_item_{amount}':
        scoreboard players remove .stacks gold 1

        scoreboard players set .r.in gold f'{amount}'
        function gold:_technical/random

        for n in range(amount):
            nthPow = 2 ** n
            if score .r.out gold matches f'{n}' run scoreboard players add .occupied gold f'{nthPow}'

        store result storage gold:container Items[-1].Slot int 1 run scoreboard players get .r.out gold
        data modify block ~ ~ ~ Items append from storage gold:container Items[-1]
        data remove storage gold:container Items[-1]

        if score .stacks gold matches 1.. run function f'gold:_technical/add_item_{amount}'

function gold:_technical/random: # random number from 0 to .r.in - 1 on r.out
    # generate random number % input
    scoreboard players operation .rseed gold *= .rmod gold
    scoreboard players operation .rseed gold += .rmod gold
    scoreboard players operation .r.out gold = .rseed gold
    scoreboard players operation .r.out gold %= .r.in gold
    # check if it exists - reroll if that is the case
    scoreboard players set .exists gold 0
    scoreboard players set .power gold 67108864 # 2 ^ 26
    for n in range(27):
        if score .exists gold matches 0 run scoreboard players operation .temp gold = .occupied gold
        if score .exists gold matches 0 run scoreboard players operation .occupied gold %= .power gold
        if score .exists gold matches 0 run scoreboard players operation .power gold /= .2 gold
        if score .r.out gold matches f'{26 - n}' unless score .occupied gold = .temp gold run scoreboard players set .exists gold 1
    if score .exists gold matches 1 run function gold:_technical/random

